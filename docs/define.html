<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<title>OzJS / define的9种使用方法和模块类型</title>

<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/pygment_trac.css">

</head>
<body>


<header>

<p class="logo">OzJS</p>
<p class="header">OzJS is a microkernel for modular javascript, with bundles of powerful yet micro-framework friendly AMD modules.</p>

<ul class="buttons">
  <li><a class="buttons github" href="https://github.com/dexteryy/OzJS">View On GitHub</a></li>
  <!--<li class="download"><a class="buttons" href="https://github.com/dexteryy/OzJS/zipball/master">Download ZIP</a></li>-->
  <!--<li class="download"><a class="buttons" href="https://github.com/dexteryy/OzJS/tarball/master">Download TAR</a></li>-->
</ul>

</header>

<nav>

<ul>
    <li><a href="/#overview">Overview</a></li>
    <li>
        <a href="/#toolchain">Toolchain</a>
        <ul>
            <li><a href="/ozma/">OzmaJS</a></li>
            <li><a href="/grunt-ozjs">grunt-ozjs</a></li>
            <li><a href="/examples/adapter/">adapter.js</a></li>
        </ul>
    </li>
    <li>
        <a href="/#framework">Micro-framework</a>
        <ul>
            <li><a href="/EventMaster/">EventMaster</a></li>
            <li><a href="/URLKit/">URLKit</a></li>
            <li><a href="/DollarJS/">DollarJS</a></li>
            <li><a href="/CordJS/">CordJS</a></li>
            <li><a href="/ChoreoJS/">ChoreoJS</a></li>
            <li><a href="/mo/">Mo</a></li>
            <li><a href="/moui/">Moui</a></li>
        </ul>
    </li>
    <li><a href="/#start">Getting Started</a></li>
    <li><a href="/#ref">References</a></li>
    <li><a href="/#release">Release History</a></li>
</ul>

</nav>


<div class="wrapper">
<section>
<h1 id="toc_35"><a href="/">OzJS</a> / [草稿]define的9种使用方法和模块类型</h1>

<h2 id="toc_36">define</h2>

<ol>
<li><p>AMD风格，推荐写法，可以直接合并到生产环境的打包文件中，模块可在保持全局唯一的前提下任意命名，不一定要跟script文件的URL相关</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;module_name&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s2">&quot;host&quot;</span><span class="p">,</span> <span class="c1">// 内建模块</span>
    <span class="s2">&quot;module_dependency&quot;</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="nx">module_dependency</span><span class="p">,</span> <span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">myname</span><span class="o">:</span> <span class="s1">&#39;yy&#39;</span> <span class="p">};</span>
<span class="p">});</span>
</code></pre>
</div></li>
<li><p>AMD风格，省略模块命名，用于临时调试或小项目，合并到生产环境之前需借助预处理工具补全模块名 </p>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">([</span>
    <span class="s2">&quot;host&quot;</span><span class="p">,</span>
    <span class="s2">&quot;module_dependency&quot;</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="nx">module_dependency</span><span class="p">,</span> <span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">myname</span><span class="o">:</span> <span class="s1">&#39;yy&#39;</span> <span class="p">};</span>
<span class="p">});</span>
</code></pre>
</div></li>
<li><p>异步模块，依赖它的代码会等到finish函数调用后才执行</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">([</span>
    <span class="s2">&quot;finish&quot;</span><span class="p">,</span>
    <span class="s2">&quot;module_dependency&quot;</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">finish</span><span class="p">,</span> <span class="nx">module_dependency</span><span class="p">,</span> <span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">){</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
        <span class="nx">exports</span><span class="p">.</span><span class="nx">myname</span> <span class="o">=</span> <span class="s1">&#39;xx&#39;</span><span class="p">;</span>
        <span class="nx">finish</span><span class="p">({</span> <span class="nx">myname</span><span class="o">:</span> <span class="s1">&#39;yy&#39;</span> <span class="p">});</span> <span class="c1">//如果finish有参数，会替代原有的exports对象</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="c1">// 不支持return</span>
<span class="p">});</span>
</code></pre>
</div></li>
<li><p>带版本号的模块名，在require或声明依赖时只需要写@前的部分，如果定义过多个版本的同名模块，会自动切换到最新版本。也可以在require时写明特定版本号</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;module_name@1.2.4&#39;</span><span class="p">,</span> <span class="p">[],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">myname</span><span class="o">:</span> <span class="s1">&#39;yy&#39;</span> <span class="p">};</span>
<span class="p">});</span>
</code></pre>
</div></li>
<li><p>远程模块，直接映射模块名到任意script文件的URL，URL和模块可以是一对多关系</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;module_name&#39;</span><span class="p">,</span> <span class="s2">&quot;http://module/path/file&quot;</span><span class="p">);</span>
</code></pre>
</div></li>
<li><p>声明远程模块的依赖关系能实现script文件的串行下载，等到依赖的所有文件下载完成之后，当前模块的文件才会开始下载（适用于缺少AMD封装的传统script文件，如jquery.mousewheel.js，对于有AMD封装的模块文件，应尽量并行下载）</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;module_name&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s2">&quot;host&quot;</span><span class="p">,</span>
    <span class="s2">&quot;module_dependency&quot;</span>
<span class="p">],</span> <span class="s2">&quot;http://module/path/file&quot;</span><span class="p">);</span>
</code></pre>
</div></li>
<li><p>同6，但省略URL，仍然视为远程模块，会基于模块名自动生成URL（参考require用法中的【模块状态1】）</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;module_name&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s2">&quot;host&quot;</span><span class="p">,</span>
    <span class="s2">&quot;module_dependency&quot;</span>
<span class="p">]);</span>
</code></pre>
</div></li>
<li><p>CommonJS风格，只有当define的参数不包含依赖数组时才会尝试从模块代码中解析依赖关系，在生产环境中作压缩时需避免替换局部变量&quot;require&quot;</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="s1">&#39;module_name&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nb">window</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;host&quot;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">module_dependency</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;module_dependency&quot;</span><span class="p">);</span>
    <span class="nx">exports</span><span class="p">.</span><span class="nx">myname</span> <span class="o">=</span> <span class="s1">&#39;yy&#39;</span><span class="p">;</span> <span class="c1">//也支持return</span>
<span class="p">});</span>
</code></pre>
</div></li>
<li><p>CommonJS风格，省略模块命名，同2和8</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nb">window</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;host&quot;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">module_dependency</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;module_dependency&quot;</span><span class="p">);</span>
    <span class="nx">exports</span><span class="p">.</span><span class="nx">myname</span> <span class="o">=</span> <span class="s1">&#39;yy&#39;</span><span class="p">;</span>
<span class="p">});</span>
</code></pre>
</div></li>
</ol>

<h2 id="toc_37">require</h2>

<ol>
<li><p>require等同于无命名、会在声明之后立刻执行的模块</p>

<p>【模块状态1】：如果&quot;module_dependency&quot;事先没有声明过（即没有执行过define），会用baseUrl加上模块名生成URL, 自动声明一个远程模块，之后同【状态2】</p>

<p>【模块状态2】：如果&quot;module_dependency&quot;已声明为远程模块，会先下载script文件，执行其中的define代码后，再重新监测依赖关系，之后同【状态3】</p>

<p>【模块状态3】：如果&quot;module_dependency&quot;已声明过代码部分，会先执行模块代码，获得return的对象或exports对象，再执行require的代码块 </p>
<div class="highlight"><pre><code class="javascript"><span class="nx">require</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span>
    <span class="nx">baseUrl</span><span class="o">:</span> <span class="s1">&#39;../&#39;</span>
<span class="p">});</span>
<span class="c1">//</span>
<span class="nx">require</span><span class="p">([</span>
    <span class="s2">&quot;module_dependency&quot;</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">module_dependency</span><span class="p">){</span>
    <span class="c1">//</span>
<span class="p">});</span>
</code></pre>
</div></li>
<li><p>require的参数用法类似define，同样支持CommonJS风格</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">require</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nb">window</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;host&quot;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">module_dependency</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;module_dependency&quot;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>
</div></li>
<li><p>模块名称前的new!是一个插件，功能是重新执行模块代码，生成新的return对象或exports对象</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">require</span><span class="p">([</span>
    <span class="s2">&quot;new!module_dependency&quot;</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">module_dependency</span><span class="p">){</span>
    <span class="c1">//</span>
<span class="p">});</span>
</code></pre>
</div></li>
<li><p>require函数执行时的this会被作为内建模块&quot;host&quot;的值，经常用于在iframe页面里调用父页面中已执行过的模块</p>
<div class="highlight"><pre><code class="javascript"><span class="nx">require</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="p">[</span>
    <span class="s2">&quot;new!module_dependency&quot;</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">module_dependency</span><span class="p">){</span>
    <span class="c1">//</span>
<span class="p">});</span>
</code></pre>
</div></li>
</ol>

</section>
</div>


</body>
</html>

